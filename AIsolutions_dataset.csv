title,solution,model,time
Median of Two Sorted Arrays,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], 
nums2: List[int]) -> float:
        m, n = len(nums1), len(nums2)
        total = m + n

        def kth(k):
            p1, p2 = 0, 0
            while True:
                if p1 == m:
                    return nums2[p2 + k]
                if p2 == n:
                    return nums1[p1 + k]
                if k == 0:
                    return min(nums1[p1], nums2[p2])
                if nums1[p1] < nums2[p2]:
                    p1 += 1
                else:
                    p2 += 1
                k -= 1

        if total % 2 == 1:
            return kth(total // 2)
        else:
            return (kth(total // 2) + kth(total // 2 - 1)) / 2",codegemma:7b,76.95955300331116
Longest Palindromic Substring,"
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        dp = [[False] * n for _ in range(n)]

        max_len = 0
        start = 0

        for i in range(n):
            for j in range(i):
                if s[i] == s[j] and (j + 1 > i - 1 or dp[j + 1][i - 1]):
                    dp[j][i] = True
                    if i - j + 1 > max_len:
                        max_len = i - j + 1
                        start = j

        return s[start:start + max_len]
",codegemma:7b,89.88442945480347
Reverse Integer,"class Solution:
    def reverse(self, x: int) -> int:
        rev = 0
        while x:
            digit = x % 10
            if rev > (0x7fffffff // 10) or (rev == (0x7fffffff // 10) and digit > 7): return 0
            if rev < (-0x80000000 // 10) or (rev == (-0x80000000 // 10) and digit < -8): return 0
            rev = rev * 10 + digit
            x //= 10
        return rev
",codegemma:7b,100.50366044044495
Regular Expression Matching,"class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)
        dp = [[False] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = True
        for i in range(1, n + 1):
            dp[0][i] = dp[0][i - 1] and p[i - 1] == '*'
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if p[j - 1] == s[i - 1] or p[j - 1] == '.':
                    dp[i][j] = dp[i - 1][j - 1]
                elif p[j - 1] == '*':
                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
        return dp[m][n]",codegemma:7b,156.76512145996094
Longest Common Prefix,"
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return """"
        prefix = strs[0]
        for string in strs[1:]:
            while string[:len(prefix)] != prefix:
                prefix = prefix[:-1]
                if not prefix:
                    return """"
        return prefix
",codegemma:7b,71.5256016254425
4Sum,"class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        res = []
        for i in range(len(nums) - 3):
            if i != 0 and nums[i] == nums[i - 1]:
                continue
            for j in range(i + 1, len(nums) - 2):
                if j != i + 1 and nums[j] == nums[j - 1]:
                    continue
                left, right = j + 1, len(nums) - 1
                while left < right:
                    sum = nums[i] + nums[j] + nums[left] + nums[right]
                    if sum == target:
                        res.append([nums[i], nums[j], nums[left], nums[right]])
                        left += 1
                        right -= 1
                        while left < right and nums[left] == nums[left - 1]:
                            left += 1
                        while left < right and nums[right] == nums[right + 1]:
                            right -= 1
                    elif sum < target:
                        left += 1
                    else:
                        right -= 1
        return res",codegemma:7b,169.5038719177246
Next Permutation,"class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place 
instead.
        """"""
        i = len(nums) - 2
        while i >= 0 and nums[i+1] <= nums[i]:
            i -= 1
        if i >= 0:
            j = len(nums) - 1
            while j > i and nums[j] <= nums[i]:
                j -= 1
            nums[i], nums[j] = nums[j], nums[i]
        left, right = i + 1, len(nums) - 1
        while left < right:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1
            right -= 1
",codegemma:7b,187.8439028263092
Combination Sum II,"
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        ans = []
        candidates.sort()

        def dfs(index, current, total):
            if total > target:
                return
            if total == target:
                ans.append(current[:])
                return
            for i in range(index, len(candidates)):
                if i > index and candidates[i] == candidates[i - 1]:
                    continue
                current.append(candidates[i])
                dfs(i + 1, current, total + candidates[i])
                current.pop()

        dfs(0, [], 0)
        return ans
",codegemma:7b,119.36075711250305
First Missing Positive,"class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        for i in range(n):
            if nums[i] <= 0 or nums[i] > n:
                nums[i] = 1
        for i in range(n):
            idx = abs(nums[i])-1
            if idx < n:
                nums[idx] = -abs(nums[idx])
        for i in range(1, n):
            if nums[i] > 0:
                return i
        if nums[0] > 0:
            return n
        return n+1
",codegemma:7b,113.91023182868958
Multiply Strings,"class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        ans = [0] * (len(num1) + len(num2))
        for i in range(len(num1) - 1, -1, -1):
            for j in range(len(num2) - 1, -1, -1):
                sum = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0')) + ans[i + j + 1]
                ans[i + j + 1] = sum % 10
                ans[i + j] += sum // 10
        start = 0
        while start < len(ans) and ans[start] == 0:
            start += 1
        return ''.join(map(str, ans[start:]))",codegemma:7b,121.55879354476929
Permutations II,"class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = [[]]
        for num in nums:
            temp = []
            for lst in ans:
                for i in range(len(lst)+1):
                    temp.append(lst[:i] + [num] + lst[i:])
            ans = temp
        return ans",codegemma:7b,78.95944929122925
